"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const useThumb_1 = __importDefault(require("./useThumb"));
/** Handle the state of a range slider */
const useRange = ({ step, range: propValue, minimumRange, minimumValue, maximumValue, slideOnTap, onValueChange, crossingAllowed }) => {
    const [range, setRange] = react_1.default.useState(propValue);
    const [minProp, maxProp] = propValue;
    // We need to access the last callback value
    const onValueChangeRef = react_1.default.useRef(onValueChange);
    onValueChangeRef.current = onValueChange;
    const updateRange = react_1.default.useCallback((rangeUpdate) => {
        setRange(oldRange => {
            const newRange = typeof rangeUpdate === 'function' ? rangeUpdate(oldRange) : rangeUpdate;
            // If no change, we return the previous object to avoir rerenders
            if (oldRange[0] === newRange[0] && oldRange[1] === newRange[1])
                return oldRange;
            // We call onValueChange as soon as the setState is over
            setTimeout(() => onValueChangeRef.current && onValueChangeRef.current(newRange), 0);
            return newRange;
        });
    }, []);
    // When the propValue changes, we need to update the min and max values accordingly
    react_1.default.useEffect(() => { updateRange([minProp, maxProp]); }, [minProp, maxProp, updateRange]);
    const updateMin = react_1.default.useCallback((newMin) => updateRange(([, oldMax]) => [newMin, oldMax]), [updateRange]);
    const updateMax = react_1.default.useCallback((newMax) => updateRange(([oldMin]) => [oldMin, newMax]), [updateRange]);
    // Min value thumb
    const { updateValue: updateMinValue, canMove: canMoveMin } = (0, useThumb_1.default)({
        minimumValue,
        maximumValue: range[1] - minimumRange,
        value: minProp,
        step,
        slideOnTap,
        onValueChange: updateMin
    });
    // Max value thumb
    const { updateValue: updateMaxValue, canMove: canMoveMax } = (0, useThumb_1.default)({
        minimumValue: range[0] + minimumRange,
        maximumValue,
        value: maxProp,
        step,
        slideOnTap,
        onValueChange: updateMax
    });
    const currentThumb = react_1.default.useRef();
    // Method to update the lower or higher bound according to which one is the closest
    const updateClosestValue = react_1.default.useCallback((value, state) => {
        const [minValue, maxValue] = range;
        // When moving a thumb, we don't want to let it cross the other thumb
        const isMinClosest = (currentThumb.current && !crossingAllowed)
            ? currentThumb.current === 'min'
            : Math.abs(value - minValue) < Math.abs(value - maxValue);
        isMinClosest ? updateMinValue(value) : updateMaxValue(value);
        if (state === 'release')
            currentThumb.current = undefined; // We release the thumb
        else if (state === 'press')
            currentThumb.current = isMinClosest ? 'min' : 'max'; // We set the thumb being currently moved
        return isMinClosest ? [value, maxValue] : [minValue, value];
    }, [range, crossingAllowed, updateMinValue, updateMaxValue]);
    const canMove = react_1.default.useCallback((value) => {
        return canMoveMax(value) || canMoveMin(value);
    }, [canMoveMin, canMoveMax]);
    return { updateMinValue, updateMaxValue, updateClosestValue, canMove, range };
};
exports.default = useRange;
