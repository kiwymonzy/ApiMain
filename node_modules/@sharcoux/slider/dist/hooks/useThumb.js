"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const useRounding_1 = __importDefault(require("./useRounding"));
/** Handle the state of a thumb for a slider */
const useThumb = (props) => {
    const { step, value: propValue, slideOnTap, minimumValue, maximumValue, onValueChange } = props;
    const [value, setValue] = react_1.default.useState(propValue || minimumValue); // The value desired
    const round = (0, useRounding_1.default)({ step, minimumValue, maximumValue });
    // This block will group close call to setValue into one single update to greatly improve perfs
    const [updated, setUpdated] = react_1.default.useState(false);
    const nextValue = react_1.default.useRef(value);
    react_1.default.useEffect(() => {
        if (updated) {
            setUpdated(false);
            setValue(nextValue.current);
        }
    }, [updated]);
    // We need to access the last callback value
    const onValueChangeRef = react_1.default.useRef(onValueChange);
    onValueChangeRef.current = onValueChange;
    /** Update the thumb value */
    const updateValue = react_1.default.useCallback((newValue) => {
        const rounded = round(newValue);
        if (rounded !== nextValue.current)
            setUpdated(true);
        nextValue.current = rounded;
    }, [round]);
    // We don't want to update the value when updateValue changes
    const updateValueRef = react_1.default.useRef(updateValue);
    updateValueRef.current = updateValue;
    // Update the value on bounds change
    react_1.default.useLayoutEffect(() => {
        updateValueRef.current(nextValue.current);
    }, [step, minimumValue, maximumValue]);
    // Update the value on propchange
    react_1.default.useLayoutEffect(() => {
        updateValueRef.current(propValue);
    }, [propValue]);
    /** Call onValueChange when the user changed the value */
    const userUpdateValue = react_1.default.useCallback((newValue) => {
        updateValue(newValue);
        onValueChangeRef.current && onValueChangeRef.current(nextValue.current);
    }, [updateValue]);
    /**
     * Indicates whether we accept to move to the specified position.
     * If the position is too far and slideOnTap is set, we don't accept sliding there
     **/
    const canMove = react_1.default.useCallback((newValue) => {
        if (slideOnTap)
            return true;
        else
            return Math.abs(newValue - value) / ((maximumValue - minimumValue) || 1) < 0.1;
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, slideOnTap ? [] : [value, step, maximumValue, minimumValue]);
    return { updateValue: userUpdateValue, canMove, value };
};
exports.default = useThumb;
